fn main() {
    let s = square(4);
    println!("square = {}", s);

    let add = {
        let a = 1;
        let b = 2;
        a + b // 最后一个没有分号的表达式的值作为返回结果
    };
    println!("add = {}", add);
}

fn square(x: i32) -> i32 {
    // x * x; //mismatched types, expected `i32`, found `()`
    x * x // 表达式，返回了它的值，注意这里没有分号！试着注释看看
}

// 思考题:
// 为什么 Rust 区分语句和表达式？这种设计对编写"函数式风格"的代码有什么帮助？
// 答：
// 1. **增强表达力**：几乎所有结构都能作为表达式使用，代码更简洁。例如：
//    let status = if online { "在线" } else { "离线" };
//    这在 Go 中需要先声明变量再用 if-else 分别赋值。
//
// 2. **减少临时变量**：表达式可以直接嵌套和组合，避免定义中间变量。
//    代码块 {} 本身就是表达式，可以包含复杂逻辑后直接返回值。
//
// 3. **更安全的隐式返回**：函数最后一个表达式自动作为返回值，避免忘记 return。
//    同时编译器会检查类型匹配，如果加了分号返回 ()，编译时就会报错。
//
// 4. **支持函数式编程风格**：表达式可以链式组合、传递给闭包、作为参数等，
//    这是函数式编程的基础。例如 iterator 链式调用：
//    vec.iter().map(|x| x * 2).filter(|x| x > 5).collect()
//
// 5. **语义明确**：区分"做事情"（语句）和"产生值"（表达式），让代码意图更清晰。
